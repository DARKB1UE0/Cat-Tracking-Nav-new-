# WHEELTEC ROS机器人底盘串口通信协议说明

## 概述

本文档详细说明STM32底盘控制板与ROS上位机之间的串口通信协议。通信使用**USART3**端口，波特率通常为**115200**。

---

## 一、通信接口说明

### 1.1 串口分配
- **USART1**: 普通串口控制（PC调试、外部设备）
- **USART3**: ROS通信专用接口 ⭐
- **UART4**: APP/OLED显示控制

### 1.2 控制模式识别
当STM32通过**USART3**接收到数据时，自动切换为ROS控制模式：
```c
if(USARTx==USART1) Set_Control_Mode(_USART_Control);
else if(USARTx==USART3) Set_Control_Mode(_ROS_Control);
```

---

## 二、ROS → STM32 接收数据帧（下行）

### 2.1 帧格式（11字节）

| 字节索引 | 字段名称 | 数据类型 | 说明 | 值/范围 |
|---------|---------|---------|------|--------|
| 0 | 帧头 | uint8_t | 固定帧头标识 | `0x7B` (123) |
| 1 | 控制模式 | uint8_t | 运动/导航模式 | 见下表 |
| 2 | Vx高字节 | uint8_t | X轴目标速度高8位 | -32768~32767 |
| 3 | Vx低字节 | uint8_t | X轴目标速度低8位 | (mm/s) |
| 4 | Vy高字节 | uint8_t | Y轴目标速度高8位 | -32768~32767 |
| 5 | Vy低字节 | uint8_t | Y轴目标速度低8位 | (mm/s) |
| 6 | Vz高字节 | uint8_t | Z轴目标角速度高8位 | -32768~32767 |
| 7 | Vz低字节 | uint8_t | Z轴目标角速度低8位 | (mrad/s) |
| 8 | 保留 | uint8_t | 预留扩展 | 通常为0 |
| 9 | 校验和 | uint8_t | BCC异或校验 | XOR(字节0~8) |
| 10 | 帧尾 | uint8_t | 固定帧尾标识 | `0x7D` (125) |

### 2.2 控制模式字段说明（字节1）

| 值 | 模式名称 | 功能说明 |
|---|---------|---------|
| `0x00` | 正常运动控制 | ROS发送速度指令控制机器人移动 |
| `0x01` | 自动回充导航 | 导航至充电桩（非红外对接） |
| `0x02` | 阿克曼导航 | 阿克曼车型专用导航模式 |
| `0x03` | 红外对接速度 | 设置红外对接时的运动速度 |
| `0xFF` | IP地址帧 | 特殊帧：传输IP地址配置 |

### 2.3 速度数据解析

#### 2.3.1 16位速度值组合
```c
// 将高低字节合并为有符号16位整数
short speed_raw = (High_Byte << 8) | Low_Byte;

// 转换为实际速度（m/s）
float actual_speed = speed_raw / 1000.0f + (speed_raw % 1000) * 0.001f;
```

#### 2.3.2 速度单位
- **线速度（Vx, Vy）**: mm/s（毫米/秒）
  - 实际值 = 接收值 / 1000（转换为m/s）
  - 范围：-32.768 ~ 32.767 m/s
  
- **角速度（Vz）**: mrad/s（毫弧度/秒）
  - 实际值 = 接收值 / 1000（转换为rad/s）
  - 范围：-32.768 ~ 32.767 rad/s

#### 2.3.3 坐标系说明
- **Vx**: 前进/后退方向速度（正值=前进，负值=后退）
- **Vy**: 左右平移速度（仅麦克纳姆轮有效，正值=右移，负值=左移）
- **Vz**: 自转角速度（正值=逆时针，负值=顺时针）

### 2.4 BCC校验算法
```c
uint8_t Check_BCC(const uint8_t *data, uint16_t length) {
    uint8_t bcc = 0;
    for (uint16_t i = 0; i < length; i++) {
        bcc ^= data[i];  // 异或运算
    }
    return bcc;
}
```

### 2.5 接收示例

#### 示例1：正常前进指令
```
发送数据（十六进制）：
7B 00 03 E8 00 00 00 00 00 XX 7D
          ^^^^^ Vx=1000mm/s=1m/s (前进)
```

#### 示例2：麦克纳姆轮全向移动
```
发送数据（十六进制）：
7B 00 01 F4 01 F4 00 00 00 XX 7D
          ^^^^^ Vx=500mm/s
                ^^^^^ Vy=500mm/s
（向前+向右，45度斜向移动）
```

#### 示例3：原地旋转
```
发送数据（十六进制）：
7B 00 00 00 00 00 01 F4 00 XX 7D
                      ^^^^^ Vz=500mrad/s（逆时针旋转）
```

---

## 三、STM32 → ROS 发送数据帧（上行）

### 3.1 帧格式（24字节）

| 字节索引 | 字段名称 | 数据类型 | 说明 | 单位 |
|---------|---------|---------|------|-----|
| 0 | 帧头 | uint8_t | 固定帧头 | `0x7B` |
| 1 | 状态标志 | uint8_t | 电机使能状态 | 0=正常, 1=失能 |
| 2-3 | Vx实际速度 | int16_t | X轴当前速度 | mm/s |
| 4-5 | Vy实际速度 | int16_t | Y轴当前速度 | mm/s |
| 6-7 | Vz实际角速度 | int16_t | Z轴当前角速度 | mrad/s |
| 8-9 | 加速度X | int16_t | IMU加速度X轴 | mg或原始值 |
| 10-11 | 加速度Y | int16_t | IMU加速度Y轴 | mg或原始值 |
| 12-13 | 加速度Z | int16_t | IMU加速度Z轴 | mg或原始值 |
| 14-15 | 角速度X | int16_t | IMU陀螺仪X轴 | 原始值 |
| 16-17 | 角速度Y | int16_t | IMU陀螺仪Y轴 | 原始值 |
| 18-19 | 角速度Z | int16_t | IMU陀螺仪Z轴 | 原始值 |
| 20-21 | 电池电压 | uint16_t | 电池电压值 | mV |
| 22 | 校验和 | uint8_t | BCC校验 | XOR(0~21) |
| 23 | 帧尾 | uint8_t | 固定帧尾 | `0x7D` |

### 3.2 状态标志字段（字节1）

| 值 | 含义 | 说明 |
|---|------|-----|
| `0` | 正常运行 | 电机使能，机器人可正常运动 |
| `1` | 软件失能 | 电机失能，机器人停止（通常因超时保护） |

### 3.3 速度数据来源

速度数据通过**正向运动学**计算得出，从编码器读数推算实际速度：

```c
// 不同车型使用不同的正向运动学模型
#if defined AKM_CAR || defined DIFF_CAR
    vel = Kinematics_akm_diff(MOTOR_A, MOTOR_B);
#elif defined MEC_CAR || defined _4WD_CAR
    vel = Kinematics_mec_4wd(MOTOR_A, MOTOR_B, MOTOR_C, MOTOR_D);
#elif defined OMNI_CAR
    vel = Kinematics_omni(MOTOR_A, MOTOR_B, MOTOR_C);
#endif
```

### 3.4 IMU数据坐标转换

⚠️ **重要**：STM32发送的IMU数据已进行坐标系转换，适配ROS标准坐标系：

```c
// 加速度计坐标转换
Send_Data.Accelerometer.X =  imu.accel.y;  // IMU的Y轴 → ROS的X轴
Send_Data.Accelerometer.Y = -imu.accel.x;  // IMU的X轴取反 → ROS的Y轴
Send_Data.Accelerometer.Z =  imu.accel.z;  // IMU的Z轴 → ROS的Z轴

// 陀螺仪坐标转换
Send_Data.Gyroscope.X =  imu.gyro.y;   // IMU的Y轴 → ROS的X轴
Send_Data.Gyroscope.Y = -imu.gyro.x;   // IMU的X轴取反 → ROS的Y轴
Send_Data.Gyroscope.Z =  imu.gyro.z;   // IMU的Z轴 → ROS的Z轴（机器人静止时强制为0）
```

### 3.5 电池电压计算

```c
// 发送端（STM32）
voltage_send = actual_voltage * 1000;  // 例：12.6V → 12600mV

// 接收端（ROS）
actual_voltage = voltage_receive / 1000.0;  // 12600 → 12.6V
```

### 3.6 数据发送频率

```c
#define DATA_TASK_RATE  RATE_20_HZ  // 20Hz（每50ms发送一次）
```

---

## 四、自动回充数据帧（可选）

仅在安装充电装置时启用（`SysVal.HardWare_charger==1`）

### 4.1 帧格式（8字节）

| 字节索引 | 字段名称 | 说明 | 值 |
|---------|---------|-----|---|
| 0 | 帧头 | 充电数据帧头 | `0x7C` |
| 1-2 | 充电电流 | 当前充电电流 | int16_t (mA) |
| 3 | 红外状态 | 是否检测到红外信号 | 0/1 |
| 4 | 充电状态 | 是否正在充电 | 0/1 |
| 5 | 回充使能 | 自动回充开关 | 0/1 |
| 6 | 校验和 | BCC校验 | XOR(0~5) |
| 7 | 帧尾 | 充电数据帧尾 | `0x7F` |

---

## 五、特殊功能帧

### 5.1 IP地址配置帧

用于配置网络参数，字节1为`0xFF`时识别为IP帧：

```
接收格式：
7B FF XX IP0 IP1 IP2 IP3 XX XX 7D
             ^^^^^^^^^^^ IP地址4字节
```

需连续接收**50次相同IP**才确认有效（防抖设计）。

---

## 六、ROS端示例代码

### 6.1 Python发送速度指令

```python
import serial
import struct

class WheeltecSerial:
    def __init__(self, port='/dev/ttyUSB0', baudrate=115200):
        self.ser = serial.Serial(port, baudrate)
    
    def send_velocity(self, vx, vy, vz, mode=0):
        """
        发送速度指令
        vx, vy: m/s (线速度)
        vz: rad/s (角速度)
        mode: 控制模式 (默认0)
        """
        # 转换为mm/s和mrad/s
        vx_mm = int(vx * 1000)
        vy_mm = int(vy * 1000)
        vz_mrad = int(vz * 1000)
        
        # 构建数据帧
        frame = bytearray([
            0x7B,  # 帧头
            mode,  # 控制模式
            (vx_mm >> 8) & 0xFF,   # Vx高字节
            vx_mm & 0xFF,          # Vx低字节
            (vy_mm >> 8) & 0xFF,   # Vy高字节
            vy_mm & 0xFF,          # Vy低字节
            (vz_mrad >> 8) & 0xFF, # Vz高字节
            vz_mrad & 0xFF,        # Vz低字节
            0x00,  # 保留字节
        ])
        
        # 计算校验和
        checksum = 0
        for byte in frame:
            checksum ^= byte
        frame.append(checksum)
        frame.append(0x7D)  # 帧尾
        
        self.ser.write(frame)

# 使用示例
robot = WheeltecSerial('/dev/ttyUSB0')
robot.send_velocity(0.5, 0, 0.3)  # 前进0.5m/s，逆时针0.3rad/s
```

### 6.2 Python解析反馈数据

```python
def parse_feedback(data):
    """解析STM32返回的24字节反馈数据"""
    if len(data) != 24:
        return None
    
    if data[0] != 0x7B or data[23] != 0x7D:
        return None
    
    # 校验
    checksum = 0
    for i in range(22):
        checksum ^= data[i]
    if checksum != data[22]:
        return None
    
    # 解析速度（带符号16位整数）
    vx = struct.unpack('>h', bytes([data[2], data[3]]))[0] / 1000.0
    vy = struct.unpack('>h', bytes([data[4], data[5]]))[0] / 1000.0
    vz = struct.unpack('>h', bytes([data[6], data[7]]))[0] / 1000.0
    
    # 解析IMU
    accel_x = struct.unpack('>h', bytes([data[8], data[9]]))[0]
    accel_y = struct.unpack('>h', bytes([data[10], data[11]]))[0]
    accel_z = struct.unpack('>h', bytes([data[12], data[13]]))[0]
    
    gyro_x = struct.unpack('>h', bytes([data[14], data[15]]))[0]
    gyro_y = struct.unpack('>h', bytes([data[16], data[17]]))[0]
    gyro_z = struct.unpack('>h', bytes([data[18], data[19]]))[0]
    
    # 解析电压
    voltage = struct.unpack('>H', bytes([data[20], data[21]]))[0] / 1000.0
    
    return {
        'status': data[1],
        'velocity': {'x': vx, 'y': vy, 'z': vz},
        'accel': {'x': accel_x, 'y': accel_y, 'z': accel_z},
        'gyro': {'x': gyro_x, 'y': gyro_y, 'z': gyro_z},
        'voltage': voltage
    }
```

---

## 七、通信注意事项

### 7.1 启动延时保护
- STM32在启动后前**10秒**（`CONTROL_DELAY`）内不处理串口数据
- 防止初始化未完成时误触发

### 7.2 超时保护
- 如果连续一段时间未收到指令，`robot_control.command_lostcount`计数器递增
- 超时后自动停止电机，防止失控

### 7.3 数据发送时机
```c
robot_control.command_lostcount = 0;  // 每次收到有效指令清零
```

### 7.4 字节序
- **大端序（Big-Endian）**：高字节在前
- 例：速度值1000 → `0x03 0xE8`（高字节=3，低字节=232）

### 7.5 调试建议
1. 使用串口助手监控原始数据
2. 验证帧头帧尾和校验和
3. 确认波特率配置一致（115200）
4. 检查USB转串口驱动是否正常

---

## 八、源码文件位置

### 8.1 核心文件

| 文件路径 | 功能描述 |
|---------|---------|
| `BALANCE/uartx_callback.c` | 串口接收中断处理（第393行：USART3接收） |
| `BALANCE/uartx_callback.h` | 接收数据结构定义 |
| `BALANCE/data_task.c` | 数据打包与发送（第198行：USART3发送） |
| `BALANCE/data_task.h` | 发送数据结构定义 |
| `HARDWARE/uartx.c` | 串口底层驱动 |

### 8.2 关键函数

```c
// 接收处理
static void UartxControll_Callback(USART_TypeDef* USARTx, uint8_t Usart_Receive);
int USART3_IRQHandler(void);

// 数据打包
static void data_transition(void);

// 发送任务
static void Usart3_SendTask(void);

// 校验算法
uint8_t Check_BCC(const uint8_t *data, uint16_t length);

// 速度解析
static float XYZ_Target_Speed_transition(u8 High, u8 Low);
```

---

## 九、版本信息

- **文档版本**: v1.0
- **适用固件**: WHEELTEC_C50X_2025.12.26
- **更新日期**: 2026年2月4日
- **作者**: WHEELTEC

---

## 十、常见问题

### Q1: 机器人不响应ROS指令？
**A**: 检查以下项目：
1. 确认使用USART3端口
2. 验证波特率为115200
3. 检查帧头帧尾是否正确（0x7B和0x7D）
4. 计算校验和是否正确
5. 确认启动延时已过（10秒后）

### Q2: 速度控制不准确？
**A**: 
1. 确认单位转换正确（m/s → mm/s需乘1000）
2. 检查正负号是否正确
3. 验证机器人运动学参数配置

### Q3: IMU数据异常？
**A**:
1. 注意坐标系已转换，直接使用即可
2. 陀螺仪Z轴在机器人静止时为0
3. 需根据具体IMU型号校准量程

### Q4: 如何切换控制模式？
**A**: 
- 发送数据到USART1 → 自动切换为串口控制模式
- 发送数据到USART3 → 自动切换为ROS控制模式
- 按APP前进键 → 切换为APP控制模式

---

## 附录：完整帧格式图示

### 下行帧（ROS → STM32）
```
┌─────┬──────┬────────┬────────┬────────┬────────┬────────┬────────┬──────┬────────┬─────┐
│ 7B  │ Mode │Vx_High │Vx_Low  │Vy_High │Vy_Low  │Vz_High │Vz_Low  │ 00   │  BCC   │ 7D  │
│帧头 │ 模式 │        Vx速度        │        Vy速度        │        Vz角速       │保留  │校验和│帧尾 │
└─────┴──────┴────────┴────────┴────────┴────────┴────────┴────────┴──────┴────────┴─────┘
 Byte0  Byte1  Byte2    Byte3    Byte4    Byte5    Byte6    Byte7   Byte8   Byte9  Byte10
```

### 上行帧（STM32 → ROS）
```
┌─────┬──────┬────────────┬────────────┬────────────┬─────────────┬─────────────┬─────────────┬────────────┬────────┬─────┐
│ 7B  │Status│     Vx     │     Vy     │     Vz     │   Accel_X   │   Accel_Y   │   Accel_Z   │   Gyro_X   │...     │ 7D  │
│帧头 │ 状态 │  实际速度  │  实际速度  │  实际角速  │  加速度X    │  加速度Y    │  加速度Z    │  角速度X   │        │帧尾 │
└─────┴──────┴────────────┴────────────┴────────────┴─────────────┴─────────────┴─────────────┴────────────┴────────┴─────┘
 Byte0  Byte1  Byte2~3     Byte4~5      Byte6~7      Byte8~9       Byte10~11     Byte12~13     Byte14~15    ...     Byte23
                                                                                                 继续Gyro_Y/Z + 电压
```

---

**如有疑问，请参考源码或联系WHEELTEC技术支持**
